组件聚合： 主要说的是组件内部的设计
（1）REP：复用/发布等同原则
软件复用的最小力度等同于其发布的最小粒度。
（2）CCP：共同闭包原则
将由于相同原因而修改，并且需要同时修改的东西放在一起。 将由于不同原因而修改，并且不能同时修改的东西分开。
（3）CRP：共同复用原则
共同复用的类和模块放在同一个组件中，一个模块中的类应该共同依赖类似或者相同的类。 简单来说就是不要依赖不需要的东西。

这三个原则存在竞争关系， 版本初期要重视CCP，类似的函数和功能往一起塞。 中后期要做调整和拆分，不同的模块再细化，稳定的下沉。

组件耦合：主要说的是组件之间的设计
（1）无依赖环原则
这个说的非常简单，就是不要有循环依赖！！ 无论是类之间的还是组件之间的。
（2）稳定依赖原则
入向越多越稳定，出向越多越不稳定。  out/(in + out)  越小越稳定。
组件之间的依赖关系应该是从最不稳定依次依赖向稳定的，最稳定的在最下层
（3）稳定抽象原则
组件的抽象程度应该与他的稳定性保持一致。

整体结合起来看，越稳定的就应该越抽象， 越多变的就要越具体，便于修改。 组合象限来看，两端的是最佳设计。

什么是软件架构：
规划如何将系统切分成组件，并安排好组件之间的排列关系、通信方式的工作。 目的是为了能够更好的进行软件的开发、部署、维护和运行。
1.好的软件架构是为了支撑软件系统的完整生命周期
2.一键式的轻松部署也是架构设计的目标之一
3.不考虑其他因素，软件架构会朝着组织结构的方向演进。（五个团队开发，会演变成五个组件）
4.将系统切割为组件，使用稳定的接口隔离，是一个比较好的注意。
5.软件系统的两种主要元素：策略和细节， 策略指业务规则和操作过程；细节指设备、DB、WEB系统、服务器、框架等等。   好的架构就是将策略摆脱细节，越晚设定细节，结构策略越理想。（因为在早期，很多细节无法敲定。 晚点与细节纠缠，可以保证我们一直拥有更多的选择。 而更多地选择本身，就是良好架构的判断标准）
6.一个优秀的软件设计师应该致力于最大化可选项数量。
7.让高层策略与实现细节脱钩！

独立性：
按层解耦：UI界面、应用独有的业务逻辑、普适的业务逻辑、数据库
重复：以场景（用例：Use-Case）来划分代码模块， 注意不同的场景中用到的代码，如果是一样的，那么这里是假的重复，未来的变更会导致这里的代码发成变化而产生区别。  在不同的场景中合并代码，抽取统一函数是愚蠢的。
解耦模式：源码层次、部署层次、服务层次（SOA）， 鼓励服务层次解耦，也就是现在所说的微服务架构 SOA：Service-oriented architecture  （SOA方式有两个缺陷：解耦不够精细；成本很高）

划分边界：
1.准确的划清边界，可以延后一些细节性的设计，提升软件的架构价值
2.I/O是无关紧要的，也就是说，UI界面应该也是后期决定的细节而不是系统本身。
3.业务逻辑不需要关心数据库层，也不需要了解UI层。
4.插件式架构：组件隔离，便于拔插。 
5.划分界限实际上就是SRP（单一职责）原则的具体实现。

边界剖析：
1.边界是一种防火墙，或者说一种划分
2.类、jar、war、进程、服务， 边界级别逐渐上升，跨边界成本也随之上升

策略与层次：
1.软件架构常常需要将组建重排列组合成一个有向无环图。
2.某一个策略离输入输出越远，那么他的层级就越高，反之越低。（本书中的定义方式，界面最低，DB最高）
3.低层组件应该成为高层组件的插件

业务逻辑：
1.实际赚钱的业务，一般来说与是否在计算机中进行没关系。 比如说流程流转是在系统中还是在纸上，业务价值是一样的，只不过系统更高效更准确。
2.关键业务+关键业务数据 = 业务实体
3.业务实体不关心数据的存储方式和展示方式，只关心真实业务逻辑
4.用例：描述了业务实体和业务实体间的交互方式
5.业务逻辑是系统的真正核心，它应该是最高可复用的代码，脱离细节实现。

架构的主题和目标：
1.架构的本身不等于使用的框架和技术，架构应该以用例或者说实际业务逻辑为主体的设计方式，所有的架构都为了满足业务逻辑。 （比如说住宅的设计，架构是基于如何满足入住的诉求，跟用砖头还是茅草来建没有关系）
2.架构本身要注重可测试性， 剥离UI和DB进行业务逻辑的测试， 剥离具体细节的测试最佳。

整洁的架构：
1.业务实体->用例->接口->框架和驱动
2.遵循顺序，注意跨越边界的场景

不完全边界（partial bounday）：
1.太过严格和细化的未来设计往往没有必要，这样做的成本也非常之高，所以不完全边界是一种选择方式。
2.三种不完全边界设计方式：门户模式、单项模式和省却最后一步。
3.YAGNI原则： You're not Going to Need it！

层次与边界：
1.任何地方都可以设置架构边界或者成为架构边界
2.架构边界的价值和成本需要对比，甚至需要调整。 然后过度的架构边界和缺乏架构边界一样可怕，甚至更可怕一点。
3.找到添加架构边界带来收益和成本对比的拐点是架构师的重要职责，也是能力区分的关键。

宏观与微观：
1.微服务或者说服务的架构不是万能金丹
2.微服务和服务严格来说只是一种软件架构的方式，它本身并不是架构
3.服务化并不代表解耦，关键还是在于代码接口上的划分和边界的划分。 服务的接口和函数的接口并没有本质上的区别
4.服务化也不是大型软件的唯一解，并不是使用了服务化的架构方式，就能进行dev-ops。 归根到底还是代码和设计本身是否优秀。
5.服务本身不存在架构边界也不应该成为架构变价， 服务内部的组件才是架构边界，需要好好设计。

测试边界：
1.测试代码或者说测试组件也是系统的一部分，而且是很关键的一部分
2.测试代码相当于最顶层的业务组件，对所有的业务进行测试。
3.测试专用API可以用于测试代码与业务逻辑代码解耦，避免结构性耦合。
4.好的测试组件代码架构可以与业务逻辑架构互相促进，是测试代码更细节更具体，业务逻辑代码更抽象更通用。
5.一个实现类的变更导致一大堆测试代码的变更，叫做脆弱的测试问题（fragile tests problem）

整洁的嵌入式架构（这一章节大部分讲硬件和软件的关系，如果做界限划分）：
软件构建的三个过程：
1.先让代码工作起来 ----这样才能带来价值
2.在试图将它变好  ----提升架构价值，便于拓展等等
3.最后让它运行的更快  -----提升性能

数据库只是实现细节
1.数据本身很重要，数据模型也很重要，但是数据库只是一种存储方式，用什么数据库不是关键。
2.数据本身理论上不应该依赖于数据库
3.内存数据库中，应该不关心什么数据结构。

Web是实现细节
1.web类似于UI，只是在于展示方式，它与桌面应用程序没有本质区别，只是展现方式不同。
2.结合上一节想想DB、UI都是实现细节，再看下一章发现框架也是。 真正核心的是业务逻辑。

应用程序框架是实现细节
1.框架不是架构
2.框架是实现细节，应该在外圈，不应该嵌入你的业务逻辑
3.使用框架，不要绑定框架
这里感触颇深，我们现在与activiti框架严重绑定，想要升级非常困难，基本已经嫁给框架，我也不知道为什么要升级，也不知道升级可以给我带来什么价值，但是一定要升级，非常痛苦。

拾遗：
1.纯粹的MVC分层或者按功能分层都是不是好的选择。 根据业务，做端口和适配器， 将系统划分为领域和基础设施。
2.注意java的封装，所有函数都public会导致架构失效，失去硬性的约束，代码很快会朝着坏的方向发展。
3.不考虑实现细节，再好的架构也会很快崩溃。


